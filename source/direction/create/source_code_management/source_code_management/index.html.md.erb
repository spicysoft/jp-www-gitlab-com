--- 
layout: markdown_page 
title: "Category Direction - Source Code Management" 
description: "Source Code Management provides the core workflows and controls for teams to collaborate using Git to build great software. Find more information here!" 
canonical_path: "/direction/create/source_code_management/source_code_management/" 
--- 

- TOC 
{:toc} 

## Source Code Management 

| Section | Stage | Maturity |  
| --- | --- | --- |  
| [Dev](/direction/dev/) | [Create](https://about.gitlab.com/stages-devops-lifecycle/create/) | [Loveable](/direction/maturity/) |  

### Introduction and how you can help 
The Source Code Management direction page belongs to the [Source Code](/handbook/product/categories/#source-code-group) group of the [Create](/stages-devops-lifecycle/create/) stage, and is maintained by [Torsten Linz](https://gitlab.com/tlinz), who can be reached at tlinz@gitlab.com. 

This direction is a work in progress, and everyone can contribute. Sharing your feedback directly is the best way to contribute to our strategy and vision. Please, comment and contribute in the linked [issues](https://gitlab.com/groups/gitlab-org/-/issues?scope=all&utf8=%E2%9C%93&state=opened&label_name[]=group%3A%3Asource%20code) and [epics](https://gitlab.com/groups/gitlab-org/-/epics?scope=all&utf8=%E2%9C%93&state=opened&label_name[]=group%3A%3Asource%20code) or raise an issue yourself in [gitlab-org/gitlab](https://gitlab.com/gitlab-org/gitlab/-/issues/) if you don't find existing feedback that matches your thoughts.  

## Overview 

Source code management (SCM) is the foundation of an organization's software development practice.  

Building great software depends on teams working well together. Teams can rarely be divided into areas of complete independence. As cross-functional security, compliance, and growth teams are formed, or new services and libraries are created, effective coordination and collaboration are essential. 

To achieve this, teams need to protect production while making it easy for everyone to contribute. Source Code Management provides the controls to define the rules and workflows for this purpose:  
- Who has the rights to view or change the code ([visibility](https://docs.gitlab.com/ee/user/public_access.html); [members](https://docs.gitlab.com/ee/user/project/members/); [permissions](https://docs.gitlab.com/ee/development/permissions.html); [merge request approvals](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/index.html); [forking and mirroring](https://docs.gitlab.com/ee/user/project/repository/forking_workflow.html)) 
- Who owns the code and is responsible for it and thus has the right to approve changes to it ([codeowners](https://docs.gitlab.com/ee/user/project/code_owners.html); [merge request approvals](https://docs.gitlab.com/ee/user/project/merge_requests/approvals/index.html)) 
- Which quality tests must be passed before changes can be applied ([coverage checks](https://docs.gitlab.com/ee/ci/pipelines/settings.html#coverage-check-approval-rule); [security checks](https://docs.gitlab.com/ee/user/application_security/policies/scan-result-policies.html)) 
- Which branches need to be protected because they influence production ([default branch](https://docs.gitlab.com/ee/user/project/repository/branches/default.html); [protected branches](https://docs.gitlab.com/ee/user/project/protected_branches.html); [push rules](https://docs.gitlab.com/ee/user/project/repository/push_rules.html)) 

### Challenges  
While the principles have been around for half a century, SCM is not without challenges. SCM needs to address a large set of requirements that are partly contradicting:  
- encourage sound development practices  
- but also, be flexible enough to adjust to varying workflows  
- be intuitive   
- but also, be secure and ensure compliance  
- be fast and reliable   
- but easy to manage 

[Git](https://git-scm.com/) is the leading Version Control System (VCS) and is loved by developers. It excels at tracking changes in source code and makes it easy and transparent to merge changes from different developers into one code base. GitLab's source code management builds on top of Git adding functionality that aims to address the above requirements. For example, access control to code repositories or requiring code reviews before merging changes. Source code management and the create stage represent the most popular features in GitLab.  

Yet, despite their appeal, neither Git nor GitLab SCM are perfect. Here are the current main shortcomings:  
- GitLab's SCM UX, has shown to be partly unintuitive or uninformative. For instance, controls to enforce rules are hard to discover and understand. Another example is that source code analytics show use of programming language by byte size rather than by lines of code.   
- Git is not particularly good at working with binary files such as graphics or video content common in game development. With those media files, Git cannot interpret change on a granular level as it does with text files. So, it needs to store full copies of every new version of a media file.   
- While [Git Large File Storage (LFS)](https://docs.gitlab.com/ee/topics/git/lfs/) aims to address this, the Git process - as helpful as it is for developers - appears complex from a content creator's perspective. Especially as they cannot benefit in the same way from Git as developers do for the lack of diffability of media files.  
- Finally, Git gets slow when repositories become exceptionally large (even if they do not contain binary files). While not common such so-called monorepos are used in several large tech companies. [Partial clone](https://docs.gitlab.com/ee/topics/git/partial_clone.html) addresses some of the issues.  

### Vision 
Therefore, the vision for Source Code Management at GitLab consists of three pillars:  
- Make it easy and intuitive to manage source code so that it is secure, compliant, and encourages best development practices.    
- Make it easy to work with large binary files in GitLab. And make it easy for content creators to contribute media files to GitLab to enable better collaboration with developers to support [GitLab's mission](https://about.gitlab.com/company/mission/#mission): everyone can contribute!  
- Make it easy to work with [monorepos](ttps://about.gitlab.com/direction/monorepos/) in GitLab (note, this also touches other stages, especially the Verify stage). 

Note: SCM is not only the most used function in GitLab, but also the one with the longest history as it has been there from the beginning. As a result, we get a lot of feedback and have a long backlog of issues. Therefore, we need to spend a considerable share of our teams’ capacity on issues that are not in the center of this vision but address bugs, stability, security, and scalability to keep our users and customers happy. 

### Target Audience 
Source code management mainly targets software engineers but also anyone who is contributing to any types of project. To that end, we target all the [user personas](/handbook/product/personas/#user-personas) we describe in our handbook, with a special focus on the following: 

- **[Sasha (Software Developer):](/handbook/product/personas/#sasha-software-developer)** targets full time contributors to all types of projects (commercial, OSS, data science, etc.). These users expect and need a high level of reliability and speed in their interactions with both project files and Git. 

- **[Delaney (Development Team Lead):](/handbook/product/personas/#delaney-development-team-lead)** targets users who often times have elevated roles which allow for the management of project settings, such as access control, security, commit strategies, and mirroring. 

- **[Devon (DevOps Engineer):](/handbook/product/personas/#devon-devops-engineer)** targets engineers tasked with supporting and enabling software teams. Their tasks often revolve around platform creation and maintenance, where [GitOps](/topics/gitops/)] workflows are crucial. 

### User journeys 
The Source Code Management category is expansive and encompasses a broad set of features. Which features are leveraged, how they are leveraged, and to what extent depends on the size of development team and the complexity of the product that they are building. We find that as the team size grows, as does the complexity of the software product. For these reasons, it is challenging to define a single user journey that captures how our users move through Source Code. That being said, there are five main buckets we can use to group the jobs to be done of our users. Understanding this general workflow helps to focus product development and discovery when exploring how to streamline the Source Code experience 

![image.png](./source_code_user_journey.png) 

We intend to define and document the user journeys our specific personas take and how those differ based on the size of the development and the industry in which they work. 

<!-- 
### Challenges to address 
- What needs, goals, or jobs to be done do the users have? 
- How do users address these challenges today? What products or workarounds are utilized? 

Provide links to UX Research issues, which validate these problems exist. 
--> 

## Where we are Headed 
The following initiatives are currently in validation as we refine the problem to solve and develop solutions. 

- [Report number of lines per language in repository charts](https://gitlab.com/gitlab-org/gitlab/-/issues/17800)

   Currently, in repository analytics, we report the used programming languages only as relative percentages and base these percentages on the file sizes in bytes. As the size of files depends largely on the programming style, this is not very helpful. Also, it is not comparable to nor aggregatable with other work that is usually reported in lines of code. We have received tons of great feedback in the comments of this issue and our analysis of these now focuses on understanding which personas have which specific needs to address the problem(s) in the right way. 

- [Git for enormous repositories](https://gitlab.com/groups/gitlab-org/-/epics/773) 

   Large repositories are difficult to manage in Git because they are difficult to scale, have performance concerns, require large amounts of storage, and suffer from loss of per-service semantic versioning. We see large repositories in situations where a company has a lot of large files, such as binary assets or they are operating monolithic repository, more commonly known as monorepos. Monorepos are a software development approach where code for many projects is stored in a single repository. Monorepos provide several advantages such as reduced complexity, code reuse, easier collaboration amongst teams, and streamlined dependency management. However, they have several drawbacks as aforementioned. We have the opportunity to improve workflows for large repos via improvements to partial clone and sparse checkout. [WIP opportunity canvas can be found here](https://gitlab.com/gitlab-com/Product/-/issues/3432) - only accessible to internal GitLab team members. 

### What we recently shipped 
Since the second half of 2021, we placed special emphasis on strengthening our [SaaS offering](https://about.gitlab.com/direction/#saas-first) by focusing on ensuring feature parity with our market-leading self-managed offering. For the Source Code group, this meant delivering solutions that are scalable, performant, and secure. Therefore, until the end of Q1 2022 (14.8), we focused our attention to issues of these types:  

- [Infradev](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=closed&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=infradev&first_page_size=20): Protect GitLab.com's availability from infrastructure failure. 

- [Performance](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=closed&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=bug%3A%3Aperformance&first_page_size=20): Ensure GitLab.com performs well at scale as well as provides a great developer experience on key workflows and actions. Focus on resolving existing failure scenarios and technical debt. 

- [Security](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=closed&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=security&first_page_size=20): Ensure GitLab.com and self-managed GitLab instances are secure. 

Since the beginning of Q2 2022, we started returning to feature work to address larger topics and resolving individual issues raised by users and customers. However, we continue to spend a portion of our capacity on the above-mentioned bug types to assure our SaaS offering continues to be secure and performant.  

Here are some of the features that we recently shipped: 

- [FIPS 140-2 Compliant](https://gitlab.com/groups/gitlab-org/-/epics/6476) - FIPS compliance is a requirement for the US Govt to utilize a piece of software. It is required for any FISMA or FedRAMP system and cannot be waived. For GitLab to be directly usable within the US Govt, we need to be compliant. To contribute to GitLab's goal to meet these demands, the Source Code group contributed their share of work.  

- [Ability to enforce IP address restrictions for Git over SSH](https://gitlab.com/groups/gitlab-org/-/epics/6296) - Limiting access to requests from a trusted set of IP addresses may improve security. Until now, only the API and UI supported such access restrictions; SSH access was blocked entirely. SSH now also adheres to this restriction, and grants access only to requests coming from IP addresses in your list. 

- [Improved and faster file browsing and syntax highlighting](https://gitlab.com/gitlab-org/gitlab/-/issues/346257) - We made multiple changes to improve the experience of browsing a repository and viewing source files. Rather than reloading the full page when moving from folder to folder, we now display repository files and folders with a single VUE application. Our repository tree view is more performant and stable now and working with files is faster. We have also switched from server-side transformations for files to client-side syntax highlighting. The rendering time for large files is now up to 66% faster. 

Here are some of the customer/user issues that we recently addressed: 

- [Block Git access protocols at group level](https://gitlab.com/gitlab-org/gitlab/-/issues/365601) - To improve security, you can now block Git access protocols that you don’t use at the group level. This is similar to the GitLab administrator setting, but can now be set per group. By default, both HTTP(S) and SSH are enabled. In your group’s Settings > General > Permissions, scroll to Enable git access protocols and remove any protocols you don’t use. 

- [Gitlab API for Protected tags: use group_id or user_id to protect tags](https://gitlab.com/gitlab-org/gitlab/-/issues/344520) - Enhancement to the [Gitlab API for Protected tags](https://docs.gitlab.com/ee/api/protected_tags.html) to support setting protected tags using group_id or user_id like it is possible for [protected environments API](https://docs.gitlab.com/ee/api/protected_environments.html#protect-repository-environments) and [protected branches API](https://docs.gitlab.com/ee/api/protected_branches.html#protect-repository-branches). 

- [Project Creation Using Group Template Defaults Path to Template Path](https://gitlab.com/gitlab-org/gitlab/-/issues/208500) - Addressing a bug that led to newly created projects to land in the template sub-group when created from a template.  

### What we are currently working on 

- [Source code rules - MVC](https://gitlab.com/groups/gitlab-org/-/epics/8075) - We are bringing the settings for protected branches and merge request approvals conveniently in one single place under Settings > Repository > Branch rules. Moreover, as the name suggests, they will be viewed through the lens of a branch as they naturally relate to such. While no functionality will be changed this significantly improves discoverability and intelligibility of your settings. Previously, these settings were in far apart places making them hard to understand as we learned from user feedback including a recent SUS study.  

- GitLab is working on [making GitLab.com FedRamp compliant](https://about.gitlab.com/solutions/public-sector/fedramp/) and the source code team it contributing its share of work ([internal link](https://gitlab.com/groups/gitlab-org/-/epics/7987)).  

- We have missed our group's availability targets of 99.95% every month since April. (Worst case was in June with 99.87%.) The [root cause has been identified](https://gitlab.com/gitlab-org/gitlab/-/issues/360578.) to be a recurring CPU saturation at peak times in underlying infrastructure. It needs to be fixed on multiple levels by the source code team, the code review team and the scalability team. The work is expected to finalize around 15.4. By then it is expected that the availability hits the targets again. 

- Next to such bigger efforts, we also spend capacity on smaller [issues raised by customers](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=opened&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=customer&label_name%5B%5D=Deliverable&milestone_title=Upcoming&first_page_size=20) as we have a long list of such and want to start burning these downs after having focused on GitLab.com stability and security for a long time. 

- As mentioned above, we also continue to spend a significant portion of our capacity on [scalability of GitLab.com](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=opened&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=infradev&label_name%5B%5D=Deliverable&milestone_title=Upcoming&first_page_size=20), [performance](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=opened&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=bug%3A%3Aperformance&label_name%5B%5D=Deliverable&milestone_title=Upcoming&first_page_size=20) and [security](https://gitlab.com/groups/gitlab-org/-/issues/?sort=closed_desc&state=opened&label_name%5B%5D=group%3A%3Asource%20code&label_name%5B%5D=security&label_name%5B%5D=Deliverable&milestone_title=Upcoming&first_page_size=20) to keep up the good level that we have achieved after massive work in 2021 and early 2022 in these domains.  

In our [milestone planning issues under our prioritization & Planning epic](https://gitlab.com/groups/gitlab-org/-/epics/6592#planning-issues) you find a detailed view of work done in each iteration. In the same epic, you also find our working list for prioritization.  

### What's Next & Why 

- [Framework for Source Code Rules](https://gitlab.com/groups/gitlab-org/-/epics/6351) 

   GitLab offers a number of controls that can be implemented as safeguards. These controls such as protected branches, approval rules, code owners' approvals and many more can be put in place to enforce adherence to policies that ensure quality. A recent SUS study and other feedback suggest that users struggle finding the different controls and struggle understanding which settings interact how. [Framework for Source Code Rules](https://gitlab.com/groups/gitlab-org/-/epics/6351) aims at making it easier and more intuitive to administer your Source Code management tool. To do so we are bringing the different controls together into one single place and will organize them on a per-branch basis.  

   The [Source code rules - MVC](https://gitlab.com/groups/gitlab-org/-/epics/8075) currently being worked on.  

   After its release, we intend to also [move security approvals under branch rules](https://gitlab.com/gitlab-org/gitlab/-/issues/368467).  

   Long-term we will consider also moving settings under per-branch view that currently don't relate to branches but might benefit from attaching them to branches such as status checks or merge checks.  

- [Reorganize merge strategies](https://gitlab.com/groups/gitlab-org/-/epics/7705) 

   There are different ways for development teams to set up merge strategies depending on their software development, code review, and compliance practices. While we encourage customers practice [GitLab Flow](https://docs.gitlab.com/ee/topics/gitlab_flow.html), we also need to support different strategies as there is no one right way for our customers. This effort streamlines the settings that allow users to create different flows and adds the option.  

- Improvements to [Code owners](https://gitlab.com/groups/gitlab-org/-/epics/5886) 

   Large organizations with many projects and large projects need to enforce review policies so that they can ensure the correct teams and individuals review changes that impact them. File owners will be automatically added to related Merge Requests (separate feature), but it is also necessary to add controls to prevent changes directly to important branches without approval. 

   We should continue to improve on the [first iteration of code owners]( https://gitlab.com/groups/gitlab-org/-/epics/77). [WIP opportunity canvas can be found here](https://gitlab.com/gitlab-org/gitlab/-/issues/329980) - only accessible to internal GitLab team members. 

   - [Make it easy to get started with CODEOWNERS](https://gitlab.com/groups/gitlab-org/-/epics/5888) 

   - [Allow multiple approvals per CODEOWNER or CODEOWNER section](https://gitlab.com/gitlab-org/gitlab/-/issues/335451) 

- Improvements to the list of commits 

   - [Better display of tags in commits list view](https://gitlab.com/gitlab-org/gitlab/-/issues/18795)
   
   - [Better display of tags and branches in commit view](https://gitlab.com/gitlab-org/gitlab/-/issues/325871)  

### What is Not Planned Right Now 
The Source Code group is not investing in the following opportunities in the immediate future: 

- [Branch read access controls](https://gitlab.com/gitlab-org/gitlab-ee/issues/720) 

   Limiting which branches a user can read in a Git repository is possible in a basic sense, by only advertising a subset of refs, but it is not possible to guarantee that unreachable objects will not be sent to the client. This means that branch read access controls would be very weak, since they could not prevent exfiltration of data they do not have permission to read. 

- Path-level read access controls 

   From a commit, Git expects all trees and blobs to be reachable. Although Git supports partial clone and spares checkout, which allow data to be excluded from fetch and checkout, Git expects to be able to fetch missing objects on demand. Deliberately excluding objects by path is likely to cause unexpected failures. 

### Maturity Plan 

<!-- 
It's important your users know where you're headed next. 
The maturity plan section captures this by showing what's required to achieve the next level. 
--> 

This category is currently at the **Loveable** maturity level (see our [definitions of maturity levels](https://about.gitlab.com/direction/maturity/)). 

However, specific aspects are not yet loveable: 

- [Forking](https://gitlab.com/groups/gitlab-org/-/epics/264) 
- [Mirroring](https://gitlab.com/groups/gitlab-org/-/epics/852) 

### Performance indicators 
The primary performance indicator (PI) for our group is the [number of unique users writing to a project Git repository](https://about.gitlab.com/handbook/product/dev-section-performance-indicators/#createsource-code---gmau---unique-users-writing-to-a-project-git-repository). We want to ensure all the features in our group provide a great experience that ultimately will allow everyone to contribute more often. A great experience in our group is a critical starting point for this. 

<embed width="100%" height="400px" src="<%= signed_periscope_url(chart: 9967642, dashboard: 758607, embed: 'v2') %>">  

<embed width="100%" height="400px" src="<%= signed_periscope_url(chart: 9980442, dashboard: 758607, embed: 'v2') %>">  

Aligning with our SaaS first and product depth direction, we are also working to make performance our secondary indicator (see [related issue](https://gitlab.com/gitlab-org/gitlab/-/issues/327659 )). The intent here is to track the most heavily used services in our group and track how they improve over time. We firmly believe [speed is the killer feature](https://bdickason.com/posts/speed-is-the-killer-feature) and as such will work to provide a speedy experience to set a great stage for new and existing users. 

See more detail in the [Create:Source Code PI page section](https://about.gitlab.com/handbook/product/dev-section-performance-indicators/#createsource-code-secondary---other---gitlabcom-performance-scores). 

<%= partial("direction/create/includes/_connection-source-code-management-and-code-review.erb") %> 

<!-- TODO: public chart visualizing performance (ie Grafana chart) --> 

## Competitive Landscape 

<!-- 
Lost the top two or three competitors. 
What the next one or two items we should work on to displace the competitor at customers? 
Ideally these should be discovered through [customer meetings](/handbook/product/product-processes/#customer-meetings). 

We’re not aiming for feature parity with competitors, 
and we’re not just looking at the features competitors talk about, 
but we’re talking with customers about what they actually use, 
and ultimately what they need. 
--> 

Important competitors are [GitHub](https://github.com) and [Perforce](https://perforce.com), and increasingly [Azure DevOps](https://docs.microsoft.com/en-us/azure/devops/user-guide/alm-devops-features). 

For public open source projects, GitHub is our primary competitor, with millions of active users having chosen GitHub before the first version of GitLab ever existed. 

In most source code management capabilities, GitLab compares favorably to GitHub, the most notable exception being the maturity of forking workflows which GitHub pioneered. 
GitHub has a highly polished and fast product, which makes tasks like browsing and managing projects fast and easy. 

- [Make forking loveable](https://gitlab.com/groups/gitlab-org/-/epics/264) 

For users of [SVN (Apache Subversion)](https://subversion.apache.org/) intending to migrate to Git, GitHub is a significant competitor, particularly because GitHub supports hosting SVN repositories. 

[Perforce](https://perforce.com) competes with GitLab primarily on its ability to support enormous repositories, however, Perforce also competes on the basis of being a Centralized Version Control System. This means that Perforce not only supports granular write permissions, but granular read permissions on a branch and file path basis. While fine grained read permissions are important to some customers, large monolithic repositories may be split into smaller repositories allowing read controls and easier management. 

- [Git for enormous repositories](https://gitlab.com/groups/gitlab-org/-/epics/773) 

## Analyst Landscape 

<!-- 
What are analysts and/or thought leaders in the space talking about? 
What are one or two issues that will help us stay relevant from their perspective? 
--> 

Large file support (see [Gitaly direction](/direction/create/gitaly/)) is an ongoing area of interest because it blocks certain segments of software development from using Git. 

Similarly, extremely large repository support (see [Gitaly direction](/direction/create/gitaly/)) is also an area of interest for the same reason. 
